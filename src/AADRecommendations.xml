<recommendations>
    <recommendation>
        <!--
            The powershell property will contain the powershell script used to evaluate the recommendation.
            Data will contain a hasharray of all the evaluated data in the path of the current scope (i.e. AAD, ADFS, AADC, AADAP).
            The script will return the priority of the recommendation (P1, P2, P3) or Passed if the recommendation is already met.
        -->
        <Powershell>
            param($Data)
            if ($Data["emailOTPMethodPolicy.json"].state -ne "enabled" -or $Data["emailOTPMethodPolicy.json"].allowExternalIdToUseEmailOtp -ne "enabled") {
                return "P2"
            }
            return "Passed"
        </Powershell>
        <Category>Access Management</Category>
        <Area>Authentication Experience</Area>
        <Name>Email OTP</Name>
        <Summary>With email OTP, org members can collaborate with anyone in the world by simply sharing a link or sending an invitation via email. Invited users prove their identity by using a verification code sent to their email account</Summary>
        <Recommendation>Enable email OTP</Recommendation>
    </recommendation>
    <recommendation>
        <Powershell>
            param($Data)
            $trustedNetworks = @($Data["namedLocations.json"] | Where-Object { $_.psobject.properties.match('isTrusted').Count -and $_.isTrusted })
            if ($trustedNetworks.Count -eq 0) {
                return "P1"
            }
            return "Passed"
        </Powershell>
        <Category>Access Management</Category>
        <Area>Access Policies</Area>
        <Name>Trusted networks</Name>
        <Summary>Trusted network is a signal leveraged by identity protection to improve risk detection. Defining your trusted networks will improve detection of risk events</Summary>
        <Recommendation>Define trusted networks</Recommendation>
    </recommendation>
    <recommendation>
        <Powershell>
            param($Data)
            # filter enabled policies
            $enabledCAPolicies = @($Data["conditionalAccessPolicies.json"] | Where-Object { $_.state -eq "enabled"})

            # list policies using trusted networks conditions
            $trustedNetworkPolicies = @($enabledCAPolicies | Where-Object { 
                $null -ne $_.conditions.locations -and (`
                    ($_.conditions.locations.psobject.properties.match('includedLocations').Count -and $_.conditions.locations.includedLocations -contains "AllTrusted") -or `
                    ($_.conditions.locations.psobject.properties.match('excludedLocations').Count -and $_.conditions.locations.excludedLocations -contains "AllTrusted")
                )
            })

            # list policies using riskState conditions
            $riskPolicies = @($enabledCAPolicies | Where-Object {
                $_.conditions.signInRiskLevels.Count -gt 0 -or `
                $_.conditions.userRiskLevels.Count -gt 0
            })

            # list policies using devices conditions
            # TODO: check with Device ABAC too?
            $devicePolicies = @($enabledCAPolicies | Where-Object {
                $_.conditions.psobject.properties.match('devices').Count -and `
                $null -ne $_.conditions.devices -and (`
                    $_.conditions.devices.excludeDevices.Count -gt 0 -or `
                    $_.conditions.devices.excludeDevicesStates.Count -gt 0
                )
            })

            # list policies using device grant controls
            $deviceGrantPolicies = @($enabledCAPolicies | Where-Object {
                $null -ne $_.grantControls -and (`
                    $_.grantControls.builtInControls -contains "compliantDevice" -or `
                    $_.grantControls.builtInControls -contains "domainJoinDevice"
                )
            })

            if ($trustedNetworkPolicies.Count -eq 0 -and $riskPolicies.Count -eq 0 -and ($devicePolicies.Count -eq 0 -or $deviceGrantPolicies.Count -eq 0)) {
                return "P1"
            }
            return "Passed"
        </Powershell>
        <Category>Access Management</Category>
        <Area>Access Policies</Area>
        <Name>Conditional Access Controls (network, device and/or risks)</Name>
        <Summary>Protect your users sign-ins by applying conditional access policies including risk, device or network location controls to improve your security</Summary>
        <Recommendation>Design conditional access to include risk, device and/or netowrk location conditions</Recommendation>
    </recommendation>
    <recommendation>
        <Powershell>
            param($Data)
            $passwordAppOrSP = @($Data["AppCredentialsReport.csv"]  | Where-Object { $_.credentialType -eq "Password" })
            if ($passwordAppOrSP.Count -gt 0) {
                return "P2"
            }
            return "Passed"
        </Powershell>
        <Category>Access Management</Category>
        <Area>Credentials Management</Area>
        <Name>Programatic usage of password credentials</Name>
        <Summary>Application or Service Principals using password is discouraged to enforce the lifecycle of credentials</Summary>
        <Recommendation>Use managed identities, Windows Integrated Authentication or certificate whenever possible</Recommendation>
    </recommendation>
    <recommendation>
        <Powershell>
            param($Data)
            $expiredSecretAppOrSP = @($Data["AppCredentialsReport.csv"]  | select displayName,@{N="EndDateTime";E={Get-Date -Date $_.credentialEndDateTime}} | Group-Object -Property displayName | ForEach-Object {
                $_.Group | Sort-Object -Property EndDateTime -Descending | Select-Object -First 1
            } | Where-Object { $_.EndDateTime -lt (Get-Date).AddMonths(1) })
            if ($expiredSecretAppOrSP.Count -gt 0) {
                return "P2"
            }
            return "Passed"
        </Powershell>
        <Category>Access Management</Category>
        <Area>Credentials Management</Area>
        <Name>Application or Service Principals with expired credentials</Name>
        <Summary>Application or Service Principals credential lifecycle should be managed</Summary>
        <Recommendation>Review application or service principals with expired credentials</Recommendation>
    </recommendation>
    <recommendation>
        <Powershell>
            param($Data)
            # Select high permisions grants 
            # high permissions = Mail or ReadWrite permissions
            # filtering out microsoft and office demo tenant
            $highPermissionsGrants = @($Data["ConsentGrantReport.csv"] | where { $_.permission -match "ReadWrite|Mail" -and $_.clientOwnerTenantId -notin ("72f988bf-86f1-41af-91ab-2d7cd011db47","a942cf59-f3c6-4338-acac-d26c18783a46") })
            if ($highPermissionsGrants.Count -gt 0) {
                return "P2"
            }
            return "Passed"
        </Powershell>
        <Category>Access Management</Category>
        <Area>Access Surface Area</Area>
        <Name>Grants for high level permissions</Name>
        <Summary>Application can request high level permission trough fishing. Such permissions include those allowing "ReadWrite" actions or "Mail" operations. Regular reviews should be in place and non-necessary grants should be removed</Summary>
        <Recommendation>Review applications having high permissions and remove unnecessary grants</Recommendation>
    </recommendation>
    <recommendation>
        <Powershell>
            param($Data)
            # Select grants to deprecated resource (Azure AD Graph)
            $highPermissionsGrants = @($Data["ConsentGrantReport.csv"] | Where-Object { $_.resourceObjectId -eq "369aeace-0da3-434f-a94b-cdd518008814" })
            if ($highPermissionsGrants.Count -gt 0) {
                return "P2"
            }
            return "Passed"
        </Powershell>
        <Category>Access Management</Category>
        <Area>Access Surface Area</Area>
        <Name>Grants to legacy resources</Name>
        <Summary>Grants are present to resources that are being deprected (Azure AD Graph)</Summary>
        <Recommendation>Review applications relying on these resources and review potential migration path with developer</Recommendation>
    </recommendation>
    <recommendation>
        <PowerShell>
            param($Data)
            # TODO: check if ELM is used or not
            $userAppAssignments = @($Data["appRoleAssignments.csv"] | Where-Object { $_.principalType -eq "User" })
            if ($userAppAssignments.Count -gt 0) {
                return "P3"
            }
            return "Passed"
        </PowerShell>
        <Category>Access Management</Category>
        <Area>Application Authentication and Assignment</Area>
        <Name>User App Assignments</Name>
        <Summary>Direct assignment to user is not advisable when attestation to applications is not used</Summary>
        <Recommendation>Assign application roles to groups to have more flexibility</Recommendation>
    </recommendation>
    <recommendation>
        <PowerShell>
            param($Data)
            $allUsersAppAssignments = @($Data["appRoleAssignments.csv"] | Where-Object { $_.principalType -eq "Group" -and $_.principalDisplayName -eq "All users" })
            if ($allUsersAppAssignments.Count -gt 0) {
                return "P1"
            }
            return "Passed"
        </PowerShell>
        <Category>Identity Management</Category>
        <Area>Entitlement Management</Area>
        <Name>Assignment of Apps with "All users" group</Name>
        <Summary>The "All users" group contains both Members and Guests. Resource owners might misunderstand this group to contain only members. As a result, special condsideration should be takeb when using this group for application assignment or grant access tor resource such as SharePoint Content or Azure resources</Summary>
        <Recommendation>Fix the entittlements by creating the right groups (e.g. "all members")</Recommendation>
    </recommendation>
    <recommendation>
        <PowerShell>
            param($Data)
            # filter enabled policies
            $enabledCAPolicies = @($Data["conditionalAccessPolicies.json"] | Where-Object { $_.state -eq "enabled"})

            $requireMFACAPolicies = @($enabledCAPolicies | Where-Object { $null -ne $_.grantControls -and $_.grantControls.builtInControls -contains "mfa" })

            if ($requireMFACAPolicies.Count -eq 0)  {
                return "P2"
            }

            return "Passed"
        </PowerShell>
        <Category>Access Management</Category>
        <Area>Credentials Management</Area>
        <Name>Control MFA trough Conditional Access</Name>
        <Summary>MFA can be condigured per user or on a federated Identity Provider. Applying MFA protection trough Conditional Access provides more flexibility</Summary>
        <Recommendation>Configure authentication policies to leverage MFA requirement via conditional access</Recommendation>
    </recommendation>
    <recommendation>
        <PowerShell>
            param($Data)
            # filter enabled policies
            $enabledCAPolicies = @($Data["conditionalAccessPolicies.json"] | Where-Object { $_.state -eq "enabled"})

            # list policies using device grant controls
            $deviceGrantPolicies = @($enabledCAPolicies | Where-Object {
                $null -ne $_.grantControls -and (`
                    $_.grantControls.builtInControls -contains "compliantDevice" -or `
                    $_.grantControls.builtInControls -contains "domainJoinDevice"
                )
            })

            if ($deviceGrantPolicies.Count -eq 0) {
                return "P2"
            }
            return "Passed"
        </PowerShell>
        <Category>Access Management</Category>
        <Area>Authentication Experience</Area>
        <Name>Device Trust Access Policies</Name>
        <Summary>Authenticating devices and account for its trust type improves your security posture and usability by avoiding friction (e.g. MFA) and blocking access to untrusted devices</Summary>
        <Recommendation>Use hybrid azure ad joined or compliant devices as a control in conditional access policies</Recommendation>
    </recommendation>
    <recommendation>
        <PowerShell>
            param($Data)
            # filter enabled policies
            $enabledCAPolicies = @($Data["conditionalAccessPolicies.json"] | Where-Object { $_.state -eq "enabled"})

            # list policies using riskState conditions
            $riskPolicies = @($enabledCAPolicies | Where-Object {
                $_.conditions.signInRiskLevels.Count -gt 0 -or `
                $_.conditions.userRiskLevels.Count -gt 0
            })

            if ($riskPolicies.Count -eq 0) {
                return "P2"
            }
            return "Passed"
        </PowerShell>
        <Category>Access Management</Category>
        <Area>Access Policies</Area>
        <Name>Risk-Based Access Policies</Name>
        <Summary>Azure AD Calculates risk for every sign-in and every user. Using risk as criteria in access policies can provide a better user experience (fewer authentication prompts), better security (only prompt user when needed) and automate remediation.</Summary>
        <Recommendation>Use sign-in or user risk controls in conditional access policies</Recommendation>
    </recommendation>
    <recommendation>
        <PowerShell>
            param($Data)
            # filter enabled policies
            $enabledCAPolicies = @($Data["conditionalAccessPolicies.json"] | Where-Object { $_.state -eq "enabled"})

            # list policies using app grant control
            $appGrantPolicies = @($enabledCAPolicies | Where-Object {
                $null -ne $_.grantControls -and (`
                    $_.grantControls.builtInControls -contains "approvedApplication" -or `
                    $_.grantControls.builtInControls -contains "compliantApplication"
                )
            })

            if ($appGrantPolicies.Count -eq 0) {
                return "P2"
            }
            return "Passed"
        </PowerShell>
        <Category>Access Management</Category>
        <Area>Access Policies</Area>
        <Name>Client Application Access Policies</Name>
        <Summary>Microsoft Intune Appliucation Management (MAM) provides the ability to push data protection controls to compatible client mobile applications such as Outlook. Conditional Access can enforce policies that will restrict access to cloud services from approved and/or compatible apps</Summary>
        <Recommendation>Deploy application MAM policies to manage application configuration. Update Conditional Access policies to only allow access from MAM capables clients.</Recommendation>
    </recommendation>
    <!--
    <recommendation>
        <PowerShell>
            param($Data)
            return "Passed"
        </PowerShell>
        <Category></Category>
        <Area></Area>
        <Name></Name>
        <Summary></Summary>
        <Recommendation></Recommendation>
    </recommendation>
    -->
</recommendations>
